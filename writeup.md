# **Finding Lane Lines on the Road**
First approach to lane line aclgorithm detection.

---

**Finding Lane Lines on the Road**
The goals / steps of this project are the following:
* Make a pipeline that finds lane lines on the road
* Reflect on your work in a written report

"Starting point"
![start][./test_images/solidWhiteCurve.jpg]
"End result"
![result]:[./examples/laneLines_thirdPass.jpg]

---

### Reflection

### 1. Describe your pipeline.
- To start I do convert my image to grayscale and get the sizes of it.
- I do apply Gaussian to the image, I did try a big kernel trying to blur all the image details/noise but that didn't work well, I ended up using an small kernel to preserve all the details and filter the lines on a posterior step.
- I do apply Canny Edge to the output of Gauss, I found that the threshold between ~100-130 works fine for both colors lines.
- I cut the region of interest, here I did try different "horizon lines". A too high horizon line introduce too many lines with the rest of the cars, but a too low (heightest Y) expose too little information to work with, in expecial with the dashed lines. My thought for the challenge video is that changing the values that I have defined for this region may help with a better result. A small region without the car lines + update the horizon line may work . This probably means that these number may need to change depending on the camera position/calibration.
- Houghlines algorithm, I play a lot with these numbers, my biggest issue with the excersise was to get smooth line on the dashed lines side, to achieve that I did increase the threshold, which will filter the lines, keeping only lines with several matches. I did decrease the min_line_len and max_line_gap to get the small dashed lines, Since the threshold value is so hight that filter the noise generated by these two last values. For the challenge I do think that working with theta may help.
- Draw_lines functions, probably the part of the code in which I put more time, I did try several things, many different way trying to find an average line based on an array of points. I did found this numpy polyfit function that returns me a result line "equation", with it I'm able to project the line to the horizon line and the end of the image. Detecting if it was a right or left line it wasn't a trouble but trying to find an average line took my much more time that what I was expecting. I did added some extra filters trying to avoid some noise on the lines.
- weighted_img, just to merge the results to get the result image.


### 2. Identify potential shortcomings with your current pipeline
- Had a single line for the straight line was doable but for the dashed line it was harder, my biggest complain is that I wanted to achieve a super smooth single line like in the demo, I was able to filter much of the shirting but there is still some parts of the videos when the line does shift, in particular with the line for the dashed lines on the floor.
- I put to much time on the smoothest line that I didn't have time to actually work as I would like to on the challenge (My algorithm works really bad on it).

### 3. Suggest possible improvements to your pipeline
- Probably the regions defined will be required to change depending on the camera FOV and position.
- Probably add more filters to horizontal lines, I did add one `fix_noise = width/4` trying to fix some white lines that appears on the Yellow line video, but to fix something more visible like the video on the challenge more horizontal filters will be require, probably touch the theta value for houghLines algorithm.
- To solve light issues like in the challenge probably the add some fallbacks will be a good idea, like 2 different output of Canny edge algorithm.
